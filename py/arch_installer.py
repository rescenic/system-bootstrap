#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# arch_installer.py --- dialog program that takes user input and uses it to install Arch Linux
# - [x] preinstall_system_checks
# - [x] user_select_install_drive
# - [x] user_confirm_install
# - [x] run_reflector
# - [x] user_select_hostname
# - [x] user_select_timezone - TODO: allow user to select a different timezone
# - [x] ntp_sync
# - [x] user_select_bootloader
# - [x] user_confirm_bootloader
# - [] user_select_partition_sizes
# - [] user_confirm_partition_sizes
# - [] clean_partition_cruft
# - [] create_partitions
# - [] create_partition_filesystems
# - [] refresh_arch_keyring
# - [] generate_fstab
# - [] install_arch
# - [] set_timezone
# - [] set_hostname
# - [] user_select_root_password
# - [] enter_chroot_environment
# - [] user_postinstall_options

import getopt
import locale
import os
import subprocess
import sys
import textwrap
import time
import traceback
from collections import namedtuple
from textwrap import dedent, indent

import blkinfo
import dialog
from base import BaseDialog, DialogContextManager
from dialog import DialogBackendVersion
from humanfriendly import format_size, parse_size
from tzlocal import get_localzone
from werkzeug.utils import secure_filename

default_debug_filename = "arch_installer.debug"
progname = os.path.basename(sys.argv[0])
progversion = "0.0.1"
version_blurb = """ \
This is free software; see the source for copying conditions. \
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."""

usage = """Usage: {progname} [option ...]
Program that installs Arch Linux.

Options:
      --debug                  enable logging of all dialog command lines
      --debug-file=FILE        where to write debug information (default:
                               {debug_file} in the current directory)
  -E, --debug-expand-file-opt  expand the '--file' options in the debug file
                               generated by '--debug'
      --help                   display this message and exit
      --version                output version information and exit""".format(
    progname=progname, debug_file=default_debug_filename
)

help_msg = """\
I can hear your cry for help, and would really like to help you. However, I \
am afraid there is not much I can do for you here; you will have to decide \
for yourself on this matter.

Keep in mind that you can always rely on me. \
You have all my support, be brave!"""

params = {
    "debug": False,
    "debug_expand_file_opt": False,
    "debug_filename": default_debug_filename,
    "progversion": progversion,
}

d = None

tw = textwrap.TextWrapper(width=78, break_long_words=True, break_on_hyphens=True)


class ArchInstaller(object):
    install_drive = ""
    hostname = ""
    bootloader = ""
    timezone = ""

    def __init__(self):
        global d
        self.Dialog_instance = dialog.Dialog(dialog="dialog")
        d = BaseDialog(self.Dialog_instance)
        d.set_background_title("Arch Installer")
        self.max_lines, self.max_cols = d.maxsize(use_persistent_args=True)
        self.min_rows, self.min_cols = 24, 80
        (
            self.term_rows,
            self.term_cols,
            self.backend_version,
        ) = self.get_term_size_and_backend_version()

    def run(self):
        self.welcome_user()
        self.set_installation_drive()
        self.set_bootloader()
        self.set_hostname()
        self.set_timezone()
        self.set_partition_sizes()
        self.start_ntp_sync()
        # self.run_reflector()

    def setup_debug(self):
        if params["debug"]:
            debug_file = open(params["debug_filename"], "w")
            d.setup_debug(
                True, file=debug_file, expand_file_opt=params["debug_expand_file_opt"]
            )
            return debug_file
        else:
            return DialogContextManager()

    def get_term_size_and_backend_version(self):
        backend_version = d.cached_backend_version
        if not backend_version:
            print(
                tw.fill(
                    "Unable to retrieve the version of the dialog-like backend. "
                    "Not running cdialog?"
                )
                + "\nPress Enter to continue.",
                file=sys.stderr,
            )
            input()

        term_rows, term_cols = d.maxsize(use_persistent_args=False)
        if term_rows < self.min_rows or term_cols < self.min_cols:
            print(
                tw.fill(
                    dedent(
                        """\
             Your terminal has less than {0} rows or less than {1} columns;
             you may experience problems with the demo. You have been warned.""".format(
                            self.min_rows, self.min_cols
                        )
                    )
                )
                + "\nPress Enter to continue."
            )
            input()

        return (term_rows, term_cols, backend_version)

    def simple_msg(self, msg):
        d.msgbox(msg, height=10, width=40, title="Install Helper")

    def welcome_user(self):
        d.msgbox(
            """
                Hello, and welcome to the Arch Installer %s.\n
                This script is being run by a Python interpreter identified as follows: %s
            """
            % (params["progversion"], indent(sys.version, "  "),),
            title="Welcome to Arch Installer",
            width=50,
            height=10,
        )
        return

    def run_reflector(self):
        cmd = "Reflector"
        while True:
            reply = d.yes_no_help(
                "\nRun '%s'? It helps speed up package installs" % cmd,
                title="Speed up package downloads with %s" % cmd,
                height=8,
                width=40,
            )
            if reply == "yes":
                d.infobox(
                    "Running '%s'" % cmd.lower(), title=cmd, height=7, width=40,
                )
                reflector_cmd = "reflector --latest 200 --protocol http --protocol https --sort rate --save /etc/pacman.d/mirrorlist"
                self.run_sh_cmd(reflector_cmd, cmd)
            elif reply == "no":
                return
            elif reply == "help":
                d.msgbox(
                    help_msg, height=10, width=40, title="From Your Faithful Servant",
                )
            else:
                assert False, "Unexpected reply from run_reflector():" + repr(reply)

    def set_timezone(self):
        current_tz = str(get_localzone())
        reply = d.yes_no(
            "Set '%s' as system timezone?" % current_tz,
            height=7,
            width=50,
            no_label="Use differnt timezone",
            title="Timezone selection",
        )
        if reply == "no":
            d.msgbox("Selecting timezone...", height=10, width=60, title="Tz selection")
        else:
            ArchInstaller.timezone = current_tz

    def set_installation_drive(self):
        text = "Select a drive to install Arch on"
        Drive = namedtuple("Drive", ["name", "size", "partitions"])
        while True:
            drives = [
                Drive(
                    name=drive.get("name"),
                    size=format_size(int(drive.get("size"))),
                    partitions=drive.get("children"),
                )
                for drive in blkinfo.BlkDiskInfo().get_disks()
            ]
            code, drive = d.menu(
                text,
                height=10,
                width=50,
                menu_height=4,
                choices=[
                    (
                        drive.name,
                        "{0!r} is {1} and has {2} partitions".format(
                            drive.name, drive.size, len(drive.partitions),
                        ),
                    )
                    for drive in drives
                ],
                title="Installation drive selection",
            )

            if code:
                break
        reply = d.yes_no(
            "Install on '%s'?" % drive, height=7, width=40, title="Confirm selection",
        )
        if reply == "no":
            self.set_installation_drive()
        else:
            ArchInstaller.install_drive = drive

    def set_bootloader(self):
        while True:
            code, bootloader = d.menu(
                "Select a bootloader to use",
                height=10,
                width=50,
                choices=[
                    (
                        "Systemd-boot",
                        "A simple UEFI boot loader",
                        "Systemd-boot (Bootctl) is simple to configure but it can only start EFI executables such as the Linux kernel EFISTUB, UEFI Shell, GRUB, or the Windows Boot Manager.",
                    ),
                    (
                        "Grub2",
                        "A very powerful boot loader",
                        "GNU GRUB is a very powerful boot loader, which can load a wide variety of free operating systems, as well as proprietary operating systems with chain-loading. GRUB is designed to address the complexity of booting a personal computer.",
                    ),
                ],
                title="Arch Installer",
                help_label="More info",
                help_button=True,
                help_tags=False,
                item_help=True,
            )
            if code == "help":
                d.msgbox(bootloader, height=10, width=45)
            else:
                break

        reply = d.yes_no(
            "'%s' will be system bootloader, continue?" % bootloader,
            height=6,
            width=40,
            title="Confirm selection",
        )
        if reply == "no":
            self.set_bootloader()
        else:
            ArchInstaller.bootloader = bootloader

    def set_hostname(self, init_str=""):
        while True:
            code, hostname = d.inputbox(
                "Set system hostname",
                init=init_str,
                title="Set system hostname",
                help_button=True,
            )
            sys_hostname = secure_filename(hostname)
            if code == "help":
                d.msgbox(
                    "The hostname will be:\n'%s'" % sys_hostname,
                    height=8,
                    width=40,
                    title="System hostname help",
                )
                init_str = hostname
            else:
                break
        reply = d.yes_no(
            "'%s' will be system hostname?" % sys_hostname,
            height=6,
            width=40,
            title="Confirm selection",
        )
        if reply == "no":
            self.set_hostname()
        else:
            ArchInstaller.hostname = sys_hostname

    def set_partition_sizes(self):
        disk = blkinfo.BlkDiskInfo().get_disks({"name": self.install_drive})[0]
        disk_size = StorageInput(disk.get("size"))
        boot, root, swap = (
            StorageInput("250mib"),
            StorageInput("30gib"),
            StorageInput("10gib"),
        )
        test = StorageInput(format_size(boot.raw + root.raw + swap.raw, binary=True))
        home_size = StorageInput(format_size(disk_size.raw - test.raw, binary=True))

        while True:
            partitions = d.inputmenu(
                "Edit GPT partition defaults",
                height=25,
                width=50,
                menu_height=7,
                choices=[
                    ("/boot", boot.humanized),
                    ("/", root.humanized),
                    ("/swap", swap.humanized),
                    ("/home", home_size.humanized),
                ],
            )
            self.simple_msg(str(partitions))

    def start_ntp_sync(self):
        ntp_cmd = "timedatectl set-ntp true"
        d.infobox(
            "Running '%s'" % ntp_cmd, title="NTP sync", height=7, width=30,
        )
        self.run_sh_cmd(ntp_cmd, ntp_cmd)

    def run_sh_cmd(self, sh_cmd, name):
        start = time.time()
        output = subprocess.run(sh_cmd, shell=True, check=True, capture_output=False)
        total_time = round(time.time() - start, 2)
        if output.returncode == 0:
            d.msgbox(
                "%s finished successfully in %s seconds." % (name, total_time),
                title="Successful '%s' run" % name,
                height=7,
                width=40,
            )
            return True
        else:
            d.msgbox(
                "%s failed to run properly%s" % (name, output),
                title="Unsuccessful '%s' run" % name,
                height=7,
                width=40,
            )


class StorageInput(object):
    def __init__(self, val):
        self.raw = parse_size(val, binary=True)
        self.humanized = val
