#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# arch_installer.py --- dialog program that takes user input and uses it to install Arch Linux
# - [] preinstall_system_checks
# - [x] user_select_install_drive
# - [x] user_confirm_install
# - [x] run_reflector
# - [x] user_select_hostname
# - [x] user_select_timezone
# - [] ntp_sync
# - [] user_select_bootloader
# - [] user_confirm_bootloader
# - [] user_select_partition_sizes
# - [] user_confirm_partition_sizes
# - [] clean_partition_cruft
# - [] create_partitions
# - [] create_partition_filesystems
# - [] refresh_arch_keyring
# - [] generate_fstab
# - [] install_arch
# - [] set_timezone
# - [] set_hostname
# - [] user_select_root_password
# - [] enter_chroot_environment
# - [] user_postinstall_options

import getopt
import locale
import os
import pprint
import stat
import subprocess
import sys
import textwrap
import time
import traceback
from collections import namedtuple
from subprocess import Popen
from textwrap import dedent, indent

import blkinfo
import dialog
from base import BaseDialog, DialogContextManager
from dialog import DialogBackendVersion
from humanfriendly import format_size
from tzlocal import get_localzone
from werkzeug.utils import secure_filename

default_debug_filename = "arch_installer.debug"
progname = os.path.basename(sys.argv[0])
progversion = "0.0.1"
version_blurb = """ \
This is free software; see the source for copying conditions. \
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."""

usage = """Usage: {progname} [option ...]
Program that installs Arch Linux.

Options:
      --debug                  enable logging of all dialog command lines
      --debug-file=FILE        where to write debug information (default:
                               {debug_file} in the current directory)
  -E, --debug-expand-file-opt  expand the '--file' options in the debug file
                               generated by '--debug'
      --help                   display this message and exit
      --version                output version information and exit""".format(
    progname=progname, debug_file=default_debug_filename
)

help_msg = """\
I can hear your cry for help, and would really like to help you. However, I \
am afraid there is not much I can do for you here; you will have to decide \
for yourself on this matter.

Keep in mind that you can always rely on me. \
You have all my support, be brave!"""

params = {
    "debug": False,
    "debug_expand_file_opt": False,
    "debug_filename": default_debug_filename,
    "progversion": progversion,
}

d = None

tw = textwrap.TextWrapper(width=78, break_long_words=True, break_on_hyphens=True)


class ArchInstaller(object):
    """ArchInstaller."""

    def __init__(self):
        """__init__."""
        global d
        self.Dialog_instance = dialog.Dialog(dialog="dialog")
        d = BaseDialog(self.Dialog_instance)
        backtitle = "Arch Installer"
        d.set_background_title(backtitle)
        self.max_lines, self.max_cols = d.maxsize(backtitle=backtitle)
        self.min_rows, self.min_cols = 24, 80
        self.wizard_context = self.setup_debug()
        (
            self.term_rows,
            self.term_cols,
            self.backend_version,
        ) = self.get_term_size_and_backend_version()

        # User install options
        self.install_drive = None
        self.hostname = None

    def setup_debug(self):
        """setup_debug."""
        if params["debug"]:
            debug_file = open(params["debug_filename"], "w")
            d.setup_debug(
                True, file=debug_file, expand_file_opt=params["debug_expand_file_opt"]
            )
            return debug_file
        else:
            return DialogContextManager()

    def get_term_size_and_backend_version(self):
        """get_term_size_and_backend_version."""
        backend_version = d.cached_backend_version
        if not backend_version:
            print(
                tw.fill(
                    "Unable to retrieve the version of the dialog-like backend. "
                    "Not running cdialog?"
                )
                + "\nPress Enter to continue.",
                file=sys.stderr,
            )
            input()

        term_rows, term_cols = d.maxsize(use_persistent_args=False)
        if term_rows < self.min_rows or term_cols < self.min_cols:
            print(
                tw.fill(
                    dedent(
                        """\
             Your terminal has less than {0} rows or less than {1} columns;
             you may experience problems with the demo. You have been warned.""".format(
                            self.min_rows, self.min_cols
                        )
                    )
                )
                + "\nPress Enter to continue."
            )
            input()

        return (term_rows, term_cols, backend_version)

    def simple_msg(self, msg):
        d.msgbox(
            msg, height=15, width=60, title="From Your Faithful Servant",
        )

    def run(self):
        """run."""
        with self.wizard_context:
            self.welcome_user()
            self.run_reflector()
            self.get_installation_drive()
            self.get_hostname()
            self.get_timezone()

    def welcome_user(self):
        """welcome_user."""
        d.msgbox(
            """
                Hello, and welcome to the Arch Installer {pydlg_version}.\n
                This script is being run by a Python interpreter identified as follows: {py_version}
            """.format(
                pydlg_version=params["progversion"],
                py_version=indent(sys.version, "  "),
            ),
            width=60,
            height=15,
        )
        return

    def run_reflector(self):
        while True:
            reply = d.yes_no_help(
                "\nRun {0!r}? It helps speed up package installs".format("reflector"),
                title="Speed up package downloads",
                height=10,
                width=50,
            )
            if reply == "yes":
                d.infobox(
                    "Running {0!r}".format("reflector"),
                    title="Reflector",
                    height=7,
                    width=30,
                )
                reflector_cmd = "reflector --latest 200 --protocol http --protocol https --sort rate --save /etc/pacman.d/mirrorlist"
                start = time.time()
                output = subprocess.run(
                    reflector_cmd, shell=True, check=True, capture_output=False
                )
                end = time.time()
                total_time = round(end - start, 2)
                if output.returncode != 0:
                    d.msgbox(
                        "Reflector failed to run properly...skipping\n{}".format(
                            output
                        ),
                        title="Unsuccessful {0!r} run",
                        height=7,
                        width=50,
                    )
                else:
                    d.msgbox(
                        "Reflector finished successfully in {} seconds...".format(
                            total_time
                        ),
                        title="Successful {0!r} run",
                        height=7,
                        width=50,
                    )
                    return True
            elif reply == "no":
                return
            elif reply == "help":
                d.msgbox(
                    help_msg, height=15, width=60, title="From Your Faithful Servant",
                )
            else:
                assert False, (
                    "Unexpected reply from ArchInstallerDialog.yes_no_help(): "
                    + repr(reply)
                )

    def get_timezone(self):
        current_tz = str(get_localzone())
        reply = d.yes_no(
            """\nYou seem to be in the {0!r} timezone.\nSet it as system timezone?""".format(
                current_tz
            ),
            height=10,
            width=60,
            yes_label="Use {}".format(current_tz),
            no_label="Select differnt timezone",
            title="What timezone are you in?",
        )
        if reply == "yes":
            self.timezone = current_tz
            return True
        elif reply == "no":
            d.msgbox("Selecting timezone...", height=10, width=60, title="Tz selection")

    def get_installation_drive(self):
        """get_installation_drive."""
        text = "Select a drive to install Arch on"
        Drive = namedtuple("Drive", ["name", "size", "partitions"])
        while True:
            drives = [
                Drive(
                    name=drive.get("name"),
                    size=format_size(int(drive.get("size"))),
                    partitions=drive.get("children"),
                )
                for drive in blkinfo.BlkDiskInfo().get_disks()
            ]
            code, tag = d.menu(
                text,
                height=15,
                width=50,
                menu_height=7,
                choices=[
                    (
                        drive.name,
                        "{0!r} is {1} and has {2} partitions".format(
                            drive.name, drive.size, len(drive.partitions),
                        ),
                    )
                    for drive in drives
                ],
                title="Arch Installer",
            )

            if code:
                break
        reply = d.yes_no(
            "\nYou have chosen " "{0!r}, continue?".format(tag),
            height=10,
            width=50,
            title="An Important Question",
        )
        if reply == "yes":
            self.install_drive = tag
            return True
        elif reply == "no":
            self.get_installation_drive()

    def get_hostname(self):
        init_str = ""
        while True:
            code, answer = d.inputbox(
                "What should system hostname be?",
                init=init_str,
                title="Set system hostname",
                help_button=True,
            )
            if code == "help":
                d.msgbox(
                    "The hostname entered "
                    "so far will be {0!r}.".format(secure_filename(answer)),
                    title="Set system hostname help",
                )
                init_str = answer
            else:
                break
        self.hostname = secure_filename(answer)
        return answer


def process_command_line():
    """process_command_line."""
    global params

    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            "ftE",
            ["debug", "debug-file=", "debug-expand-file-opt", "help", "version",],
        )
    except getopt.GetoptError:
        print(usage, file=sys.stderr)
        return ("exit", 1)

    for option, value in opts:
        if option == "--help":
            print(usage)
            return ("exit", 0)
        elif option == "--version":
            print("%s %s\n%s" % (progname, progversion, version_blurb))
            return ("exit", 0)

    # Now, require a correct invocation.
    if len(args) != 0:
        print(usage, file=sys.stderr)
        return ("exit", 1)

    # Default values for parameters
    params = {
        "debug": False,
        "debug_filename": default_debug_filename,
        "debug_expand_file_opt": False,
    }

    root_dir = os.sep  # This is OK for Unix-like systems
    params["home_dir"] = os.getenv("HOME", root_dir)

    # General option processing
    for option, value in opts:
        if option == "--debug":
            params["debug"] = True
        elif option == "--debug-file":
            params["debug_filename"] = value
        elif option in ("-E", "--debug-expand-file-opt"):
            params["debug_expand_file_opt"] = True
        else:
            assert False, (
                "Unexpected option received from the " "getopt module: '%s'" % option
            )

    return ("continue", None)


def main():
    """main."""
    locale.setlocale(locale.LC_ALL, "")

    what_to_do, code = process_command_line()
    if what_to_do == "exit":
        sys.exit(code)

    try:
        app = ArchInstaller()
        app.run()
    except dialog.error as exc_instance:
        if not isinstance(
            exc_instance, dialog.PythonDialogErrorBeforeExecInChildProcess
        ):
            print(traceback.format_exc(), file=sys.stderr)

        print(
            "Error (see above for a traceback):\n\n{0}".format(exc_instance),
            file=sys.stderr,
        )
        sys.exit(1)

    sys.exit(0)


if __name__ == "__main__":
    main()
